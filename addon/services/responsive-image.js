import Ember from 'ember';

const { computed, getOwner } = Ember;

/**
 * Service class to provides images generated by the responsive images package
 *
 * @class ResponsiveImage
 * @extends Ember.Service
 * @namespace Services
 * @module responsive-image
 * @public
 */
export default Ember.Service.extend({

  /**
   * the screen's width
   * This is the base value to calculate the image size.
   * That means the {{#crossLink "Services/ResponsiveImage:getImageBySize"}}getImageBySize{{/crossLink}} will return
   * an image that's close to `screenWidth *  window.devicePixelRatio * size / 100`
   *
   * @property screenWidth
   * @type {Number}
   * @public
   */
  screenWidth: typeof screen !== 'undefined' ? screen.width : 320,

  /**
   * return the images with the different widths
   *
   * @method getImages
   * @param {String} imageName The origin name of the Image
   * @returns {Array} An array of objects with the image name and width, e.g. [{ width: 40, image: myImage40w.jpg}, ...]
   * @public
   */
  getImages(imageName) {
    return this.get('supportedWidths').map((item) => {
      return {width: item, image: this.getImageByWidth(imageName, item)};
    }, this);
  },

  /**
   * returns the image which fits for given size
   *
   * @method getImageBySize
   * @param {String} imageName The origin name of the Image
   * @param {Number} size The width of the image in percent of the screenwidth
   * @return {String} The url of the image
   * @public
   */
  getImageBySize(imageName, size) {
    let width = this.getDestinationImageWidthBySize(size);
    return this.getImageByWidth(imageName, width);
  },

  /**
   * returns the image string for the given width
   *
   * @method getImageByWidth
   * @param {String} imageName The origin name of the Image
   * @param {Number} width The width of the image
   * @return string
   * @private
   */
  getImageByWidth(imageName, width) {
    let name = this.getImageNamePart(imageName);
    let type = this.getImageType(imageName);
    return this.getImageFromMeta(`${name}${width}w.${type}`);
  },

  /**
   * returns the image string from the metadata
   *
   * @method getImageFromMeta
   * @param {String} imageName The sized name of the Image
   * @return string
   * @private
   */
  getImageFromMeta(imageName) {
    let meta = this.get('meta');
    let img = '';
    if (meta[imageName] && meta[imageName].filename) {
      img = meta[imageName].filename;
    } else {
      img = `${this.get('destinationPath')}${imageName}`;
    }
    return img;
  },

  /**
   * returns the closest supported width to the screenwidth and size
   *
   * @method getDestinationImageWidthBySize
   * @param {Number} size The width of the image in percent of the screenwidth
   * @return {Number} the supported width
   * @private
   */
  getDestinationImageWidthBySize(size) {
    let destinationWidth = this.getDestinationWidthBySize(size || 100);
    return this.get('supportedWidths').reduce((prevValue, item)=> {
      if (item >= destinationWidth && prevValue >= destinationWidth) {
        return (item >= prevValue) ? prevValue : item;
      } else {
        return (item >= prevValue) ? item : prevValue;
      }
    }, 0);
  },

  /**
   * @method getDestinationWidthBySize
   * @param {Number} size returns the physical width factored by size
   * @returns {Number}
   * @private
   */
  getDestinationWidthBySize(size)
  {
    let physicalWidth = this.get('physicalWidth');
    let factor = (size || 100) / 100;

    return physicalWidth * factor;
  },

  /**
   * @method getImageNamePart
   * @param {string} imageName the name of the origin image
   * @returns {string} the name part without the file type extension
   * @private
   */
  getImageNamePart(imageName) {
    return imageName.substr(0, imageName.lastIndexOf('.'));
  },

  /**
   * @method getImageType
   * @param {string} imageName the name of the origin image
   * @returns {string} the file type extension ( e.g. jpg)
   * @private
   */
  getImageType(imageName) {
    return imageName.substr(imageName.lastIndexOf('.') + 1);
  },

  /**
   * the path to the assets, if the baseURL points to something
   *
   * @property assetsPath
   * @readonly
   * @type string
   * @private
   */
  assetsPath: computed(function() {
    let config = getOwner(this).resolveRegistration('config:environment'),
      baseUrl = Ember.get(config, 'rootURL') || Ember.get(config, 'baseURL') || '';
    return baseUrl;
  }).readOnly(),

  /**
   * the supported widths from the configuration
   *
   * @property supportedWidths
   * @readonly
   * @type array
   * @private
   */
  supportedWidths: computed(function() {
    let config = getOwner(this).resolveRegistration('config:environment'),
      widths = Ember.get(config, 'responsive-image.supportedWidths');
    return widths;
  }).readOnly(),

  /**
   * the path where the generated images will be stored
   *
   * @property destinationPath
   * @type string
   * @readonly
   * @private
   */
  destinationPath: computed(function() {
    let config = getOwner(this).resolveRegistration('config:environment'),
      destinationDir = Ember.get(config, 'responsive-image.destinationDir'),
      assetsPath = this.get('assetsPath');

    // if assetPath is empty the first file path would lead to an absolute path, that might break things (e.g. cordova),
    // so check for empty assetPath!
    return Ember.isPresent(assetsPath) ? `${assetsPath}${destinationDir}/` : `${destinationDir}/`;
  }).readOnly(),

  /**
   * the meta values from build time
   *
   * @property meta
   * @type {string}
   * @private
   */
  meta: '__ember_responsive_image_meta__',

  /**
   * the physical width
   *
   * @property physicalWidth
   * @type {Number}
   * @readonly
   * @private
   */
  physicalWidth: computed('screenWidth', function() {
    return this.get('screenWidth') * (window && window.devicePixelRatio || 1);
  })
});
